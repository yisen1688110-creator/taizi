<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è”ç³»å®¢æœ</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body class="theme-dark">
  <div class="container customer">
    <div class="header header-mobile">
      <button id="backBtn" class="back-btn">â†</button>
      <div class="service-label">ğŸ’¬</div>
    </div>
    <div id="chat" class="chat">
      <div id="messages" class="messages"></div>
      <div class="composer">
        <button id="plusBtn" class="icon-btn">+</button>
        <textarea id="messageInput" placeholder="" rows="1"></textarea>
        <button id="emojiBtn" class="icon-btn">ğŸ™‚</button>
        <button id="sendBtn"></button>
        <div id="plusMenu" class="popup-menu hidden">
        <label class="popup-item">
          <input id="photoInput" type="file" accept="image/*" class="hidden" />
          <span id="uploadText">ä¸Šä¼ ç…§ç‰‡</span>
        </label>
        </div>
        <div id="emojiMenu" class="popup-menu hidden">
          <div class="emoji-item">ğŸ˜€</div>
          <div class="emoji-item">ğŸ‘</div>
          <div class="emoji-item">â¤ï¸</div>
          <div class="emoji-item">ğŸ‰</div>
          <div class="emoji-item">ğŸ¤”</div>
        </div>
      </div>
    </div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    try { const setupEl = document.getElementById('setup'); if (setupEl) setupEl.remove(); } catch {}
    const qs = new URLSearchParams(location.search)
    const qsToken = qs.get('token') || ''
    const lsToken = (typeof localStorage !== 'undefined' ? (localStorage.getItem('im:token') || '') : '')
    const token = qsToken || lsToken
    let apiBase = qs.get('api') || ''
    let wsBase = qs.get('ws') || ''
    const wsPath = qs.get('wspath') || ''
    const makeSocket = () => (wsBase ? io(wsBase, { auth: { token }, query: { token }, path: (wsPath || '/socket.io/') }) : io({ auth: { token }, query: { token }, path: (wsPath || '/socket.io/') }))
    const CSRF_COOKIE = 'csrf_token'
    const CSRF_HEADER = 'x-csrf-token'
    function getCookie(name){ try { const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g,'\\$1') + '=([^;]*)')); return m ? decodeURIComponent(m[1]) : '' } catch { return '' } }
    async function ensureCsrf(){ try { let t = getCookie(CSRF_COOKIE); if (!t){ const r = await fetch('/api/csrf',{ method:'GET', credentials:'include' }); const j = await r.json(); t = j && j.csrf || '' } return t || '' } catch { return '' } }
    let socket = makeSocket()
    const originalFetch = window.fetch.bind(window)
    window.fetch = (input, init = {}) => {
      try {
        let url = typeof input === 'string' ? input : (input && input.url ? input.url : '')
        if (url && url.startsWith('/api')) {
          const headers = { ...(init.headers || {}), ...(token ? { 'x-im-token': token } : {}) }
          const method = String((init && init.method) || 'GET').toUpperCase()
          if (['POST','PUT','PATCH','DELETE'].includes(method)) {
            try { const t = getCookie(CSRF_COOKIE); if (t) headers[CSRF_HEADER] = t } catch {}
          }
          if (token) {
            const hasQuery = url.includes('?')
            const hasTokenParam = /[?&](token|x-im-token)=/.test(url)
            if (!hasTokenParam) url = url + (hasQuery ? '&' : '?') + 'token=' + encodeURIComponent(token)
          }
          if (apiBase) { const base = apiBase.endsWith('/') ? apiBase.slice(0, -1) : apiBase; url = base + url }
          const req = (typeof input === 'string') ? url : new Request(url, input)
          return originalFetch(req, { ...init, headers, credentials: 'include' })
        }
      } catch {}
      return originalFetch(input, init)
    }
    socket.on('connect_error', () => {
      try {
        apiBase = apiBase || 'http://127.0.0.1:3001'
        wsBase = wsBase || 'http://127.0.0.1:3001'
        try { socket.disconnect() } catch {}
        socket = makeSocket()
        socket.on('connect', () => { if (currentPhone) socket.emit('join', { phone: currentPhone, role: 'customer' }) })
      } catch {}
    })
    socket.on('connect', () => { if (currentPhone) socket.emit('join', { phone: currentPhone, role: 'customer' }) })
    const urlParams = new URLSearchParams(location.search)
    const presetPhone = urlParams.get('phone')
    const presetName = urlParams.get('name')
    const presetAvatar = urlParams.get('avatar')
    const langParam = (urlParams.get('lang') || '').toLowerCase()
    const placeholderParam = urlParams.get('placeholder')
    const sendParam = urlParams.get('send')
    const serviceLabel = document.querySelector('.service-label')
    const backBtn = document.getElementById('backBtn')
    const phoneEl = { textContent: '' }
    const nameEl = { textContent: '' }
    const avatarEl = { src: '', style: { display: 'none' } }
    const messagesEl = document.getElementById('messages')
    const chatEl = document.getElementById('chat')
    const messageInput = document.getElementById('messageInput')
    const sendBtn = document.getElementById('sendBtn')
    const emojiBtn = document.getElementById('emojiBtn')
    const emojiMenu = document.getElementById('emojiMenu')
    const plusBtn = document.getElementById('plusBtn')
    const plusMenu = document.getElementById('plusMenu')
    const photoInput = document.getElementById('photoInput')
    const composerEl = document.querySelector('.composer')
    const previewOverlay = document.getElementById('previewOverlay') || (() => {
      const o = document.createElement('div'); o.id='previewOverlay'; o.className='preview-overlay hidden';
      // overlay style
      o.style.position='fixed'; o.style.inset='0'; o.style.background='rgba(0,0,0,0.35)'; o.style.display='flex'; o.style.alignItems='center'; o.style.justifyContent='center'; o.style.zIndex='10050';
      const b=document.createElement('div'); b.className='preview-box';
      // box style (smaller)
      b.style.width='360px'; b.style.maxWidth='92vw'; b.style.maxHeight='80vh'; b.style.background='#111d33'; b.style.borderRadius='12px'; b.style.boxShadow='0 8px 24px rgba(0,0,0,0.35)'; b.style.padding='12px'; b.style.display='flex'; b.style.flexDirection='column'; b.style.gap='12px';
      const i=document.createElement('img'); i.className='preview-image'; i.style.width='100%'; i.style.height='auto'; i.style.borderRadius='8px'; i.style.objectFit='contain'; i.style.maxHeight='56vh';
      const a=document.createElement('div'); a.className='preview-actions'; a.style.display='flex'; a.style.justifyContent='flex-end'; a.style.gap='8px'; a.style.pointerEvents='auto';
      const c=document.createElement('button'); c.textContent='å–æ¶ˆ'; c.id='previewCancelBtn'; c.type='button'; c.style.minWidth='84px'; c.style.height='32px'; c.style.borderRadius='8px'; c.style.background='#0d2545'; c.style.color='#e6f1ff'; c.style.border='1px solid #1e3b68'; c.style.cursor='pointer';
      const s=document.createElement('button'); s.textContent='å‘é€å›¾ç‰‡'; s.id='previewSendBtn'; s.type='button'; s.style.minWidth='96px'; s.style.height='32px'; s.style.borderRadius='8px'; s.style.background='#2e7de9'; s.style.color='#fff'; s.style.border='none'; s.style.cursor='pointer';
      a.appendChild(c); a.appendChild(s); b.appendChild(i); b.appendChild(a); o.appendChild(b); document.body.appendChild(o); o._img=i; o._send=s; o._cancel=c; 
      try { c.onclick = () => { cancelPreview() } } catch {}
      try { c.addEventListener('pointerdown', (e) => { e.stopPropagation(); cancelPreview() }) } catch {}
      try { c.addEventListener('touchstart', (e) => { e.stopPropagation(); cancelPreview() }) } catch {}
      try { s.onclick = () => { sendCurrentFile() } } catch {}
      try { s.addEventListener('pointerdown', (e) => { e.stopPropagation(); sendCurrentFile() }) } catch {}
      try { s.addEventListener('touchstart', (e) => { e.stopPropagation(); sendCurrentFile() }) } catch {}
      return o })()
    let pendingFile = null
    previewOverlay._currentUrl = ''
    function cancelPreview() {
      try { if (previewOverlay._currentUrl) { URL.revokeObjectURL(previewOverlay._currentUrl); previewOverlay._currentUrl = '' } } catch {}
      pendingFile = null
      previewOverlay.classList.add('hidden')
      try { photoInput.value = '' } catch {}
    }
    async function sendCurrentFile() {
      if (!pendingFile) {
        try {
          const src = String(previewOverlay && previewOverlay._img && previewOverlay._img.src || '')
          if (src && src.startsWith('blob:')) {
            const rb = await fetch(src).then(r => r.blob())
            pendingFile = new File([rb], 'image.' + (String(rb.type||'image/png').split('/')[1]||'png'), { type: rb.type||'image/png' })
          }
        } catch {}
        if (!pendingFile) return
      }
      const fd = new FormData(); fd.append('file', pendingFile)
      if (!currentPhone) {
        let p = (typeof localStorage !== 'undefined' ? (localStorage.getItem('anon_phone') || '') : '') || presetPhone || ''
        if (!p) {
          p = 'anon_' + Date.now()
          try { if (typeof localStorage !== 'undefined') localStorage.setItem('anon_phone', p) } catch {}
          try { await fetch('/api/user', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone: p, name: '', avatar: '' }) }) } catch {}
        }
        currentPhone = p
        try { socket.emit('join', { phone: currentPhone, role: 'customer' }) } catch {}
      }
      await ensureCsrf(); const t = getCookie(CSRF_COOKIE)
      let ok = false, data = null
      try {
        const res = await fetch('/api/upload', { method: 'POST', body: fd, headers: { [CSRF_HEADER]: t || '' } })
        ok = !!(res && res.ok)
        try { data = await res.json() } catch {}
      } catch {}
      if (ok && data && data.url) {
        socket.emit('message', { phone: currentPhone, sender: 'customer', content: data.url, type: 'image', reply_to: replyToId })
        replyToId = null; try { replyPreview.classList.add('hidden') } catch {}
        cancelPreview()
      } else {
        alert('ä¸Šä¼ å¤ªé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•')
      }
    }
    try { previewOverlay._cancel.addEventListener('click', cancelPreview) } catch {}
    try { previewOverlay._send.addEventListener('click', sendCurrentFile) } catch {}
    try { previewOverlay._send.addEventListener('click', (e) => { e.stopPropagation(); sendCurrentFile() }, { capture: true }) } catch {}
    try { previewOverlay._send.addEventListener('mousedown', (e) => { e.stopPropagation(); sendCurrentFile() }) } catch {}
    try {
      document.addEventListener('click', (e) => {
        const t = e.target
        if (t && t.id === 'previewCancelBtn') { cancelPreview() }
        else if (t && t.id === 'previewSendBtn') { sendCurrentFile() }
      })
    } catch {}
    try {
      window.addEventListener('keydown', (e) => {
        if (!previewOverlay.classList.contains('hidden') && e.key === 'Enter' && !e.shiftKey && !e.isComposing) {
          e.preventDefault();
          sendCurrentFile();
        }
      })
    } catch {}
    function scrollChatToBottom() {
      if (!messagesEl) return
      requestAnimationFrame(() => { messagesEl.scrollTop = messagesEl.scrollHeight })
    }

    
    let currentPhone = null
    let msgs = []
    let replyToId = null
    let isActive = true
    
    document.addEventListener('visibilitychange', () => { isActive = !document.hidden })
    window.addEventListener('focus', () => { isActive = true })
    window.addEventListener('blur', () => { isActive = false })
    const atBottom = () => (messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight) < 10
    
    function scrollToCenterEl(el) {
      if (!el) return
      const top = Math.max(0, el.offsetTop - (messagesEl.clientHeight - el.offsetHeight) / 2)
      messagesEl.scrollTo({ top, behavior: 'smooth' })
    }
    
    function getQuoteText(id) {
      if (!id && id !== 0) return null
      const sid = String(id)
      const q = msgs.find(x => String(x.id) === sid)
      if (q) return q.type === 'image' ? 'å›¾ç‰‡' : (q.content || '')
      const el = messagesEl.querySelector('[data-id="' + sid + '"]')
      if (el) return el.querySelector('.msg-image') ? 'å›¾ç‰‡' : (el.textContent || '')
      return null
    }

    const lightbox = document.createElement('div')
    lightbox.id = 'lightbox'
    lightbox.className = 'lightbox hidden'
    const lightImg = document.createElement('img')
    lightImg.id = 'lightboxImage'
    lightbox.appendChild(lightImg)
    document.body.appendChild(lightbox)
    messagesEl.addEventListener('click', e => {
      const t = e.target
      if (t && t.classList.contains('msg-image')) {
        lightImg.src = t.src
        lightbox.classList.remove('hidden')
      }
    })
    lightbox.onclick = () => {
      lightbox.classList.add('hidden')
    }

    const isEsLang = langParam === 'es'
    const labelReply = isEsLang ? 'Responder' : 'Reply'
    const labelCopy = isEsLang ? 'Copiar' : 'Copy'
    const labelRecall = isEsLang ? 'Retirar' : 'Recall'
    const labelUpload = isEsLang ? 'Subir foto' : 'Upload photo'
    const uploadTextEl = document.getElementById('uploadText')
    if (uploadTextEl) uploadTextEl.textContent = labelUpload
    // set preview action texts by lang
    try {
      previewOverlay._cancel.textContent = isEsLang ? 'Cancelar' : 'å–æ¶ˆ'
      previewOverlay._send.textContent = isEsLang ? 'Enviar foto' : 'å‘é€å›¾ç‰‡'
    } catch {}

    function renderMessage(m) {
      if (m.type === 'recall') return
      const div = document.createElement('div')
      div.className = m.sender === 'customer' ? 'msg me' : 'msg other'
      div.dataset.id = m.id || ''
      if (m.reply_to != null) {
        const rp = document.createElement('div')
        rp.className = 'reply'
        const qt = getQuoteText(m.reply_to)
        if (qt) {
          if (qt === 'å›¾ç‰‡') {
            const imgEl = messagesEl.querySelector('[data-id="' + m.reply_to + '"] .msg-image')
            if (imgEl) {
              const t = document.createElement('img')
              t.className = 'reply-thumb'
              t.src = imgEl.src
              rp.appendChild(t)
              const s = document.createElement('span')
              s.textContent = 'å›¾ç‰‡'
              rp.appendChild(s)
            } else {
              rp.textContent = 'å›¾ç‰‡'
            }
          } else {
            rp.textContent = qt
          }
        } else {
          rp.textContent = 'å¼•ç”¨æ¶ˆæ¯'
          fetch('/api/message/' + encodeURIComponent(m.reply_to)).then(r => r.ok ? r.json() : null).then(row => {
            if (!row) return
            if (row.type === 'image') {
              rp.textContent = ''
              const t = document.createElement('img')
              t.className = 'reply-thumb'
              t.src = row.content
              rp.appendChild(t)
              const s = document.createElement('span')
              s.textContent = 'å›¾ç‰‡'
              rp.appendChild(s)
            } else {
              rp.textContent = row.content || ''
            }
          })
        }
        div.appendChild(rp)
        rp.onclick = () => {
          const id = String(m.reply_to)
          let tries = 0
          const go = () => {
            const el = messagesEl.querySelector('[data-id="' + id + '"]')
            if (!el) { if (tries++ < 40) return setTimeout(go, 50); else return }
            scrollToCenterEl(el)
            el.classList.add('flash')
            setTimeout(() => { el.classList.remove('flash') }, 1200)
          }
          go()
        }
      }
      if (m.type === 'image') {
        const img = document.createElement('img')
        img.src = m.content
        img.className = 'msg-image'
        img.onload = () => { scrollChatToBottom() }
        div.appendChild(img)
      } else {
        const txt = document.createElement('div')
        txt.textContent = m.content
        div.appendChild(txt)
      }
      messagesEl.appendChild(div)
      msgs.push(m)
      scrollChatToBottom()
      div.oncontextmenu = (e) => { e.preventDefault(); openMsgMenu(e, m) }
      let t
      div.addEventListener('touchstart', () => { t = setTimeout(() => openMsgMenu({ clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 }, m), 500) })
      const cancel = () => { if (t) clearTimeout(t) }
      div.addEventListener('touchend', cancel)
      div.addEventListener('touchmove', cancel)
    }

    function setProfile({ phone, name, avatar }) {
      phoneEl.textContent = phone || ''
      nameEl.textContent = name || ''
      avatarEl.src = avatar || ''
      avatarEl.style.display = avatar ? 'block' : 'none'
    }

    async function startChat(phone, name, avatar) {
      currentPhone = (phone || '').trim()
      if (!currentPhone) return
      await fetch('/api/user', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone: currentPhone, name, avatar }) })
      setProfile({ phone: currentPhone, name, avatar })
      if (chatEl) { chatEl.classList.remove('hidden') }
      socket.emit('join', { phone: currentPhone, role: 'customer' })
      const initialMsgs = await fetch('/api/messages/' + encodeURIComponent(currentPhone)).then(r => r.json()).catch(() => [])
      ;(Array.isArray(initialMsgs) ? initialMsgs : []).forEach(renderMessage)
      setTimeout(scrollChatToBottom, 0)
      if (isActive && atBottom()) socket.emit('seen', { phone: currentPhone })
      const tryEmitSeen = () => { if (isActive && atBottom()) socket.emit('seen', { phone: currentPhone }) }
      
      const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.matchMedia('(pointer: coarse)').matches
      messagesEl.addEventListener('scroll', tryEmitSeen)
      window.addEventListener('focus', tryEmitSeen)
      messageInput.addEventListener('paste', e => {
        const cd = e.clipboardData
        if (!cd) return
        const item = Array.from(cd.items || []).find(x => x.type && x.type.indexOf('image/') === 0)
        const file = item && item.getAsFile ? item.getAsFile() : (cd.files && cd.files[0])
        if (!file) return
        if (file.size > 5 * 1024 * 1024 || !/^image\//.test(file.type)) return
        const url = URL.createObjectURL(file)
        previewOverlay._currentUrl = url
        previewOverlay._img.src = url
        pendingFile = file
        previewOverlay.classList.remove('hidden')
      })
      function updateComposerHeight() {
        const maxH = Math.floor(messagesEl.clientHeight / 3)
        messageInput.style.height = 'auto'
        const h = Math.min(messageInput.scrollHeight, maxH)
        messageInput.style.height = h + 'px'
        messageInput.style.overflowY = messageInput.scrollHeight > maxH ? 'auto' : 'hidden'
      }
      messageInput.addEventListener('input', updateComposerHeight)
      window.addEventListener('resize', updateComposerHeight)
      
      emojiBtn.onclick = (e) => {
        e.stopPropagation()
        emojiMenu.classList.toggle('hidden')
      }
      emojiMenu.querySelectorAll('.emoji-item').forEach(el => {
        el.onclick = (e) => {
          e.stopPropagation()
          messageInput.value += el.textContent
          emojiMenu.classList.add('hidden')
          messageInput.focus()
        }
      })
      plusBtn.onclick = (e) => {
        e.stopPropagation()
        plusMenu.classList.toggle('hidden')
      }
      plusMenu.onclick = (e) => {
        e.stopPropagation()
        photoInput.click()
      }
      document.addEventListener('click', () => { emojiMenu.classList.add('hidden'); plusMenu.classList.add('hidden') })
      photoInput.onchange = () => {
        const f = photoInput.files[0]
        if (!f) return
        if (f.size > 5 * 1024 * 1024) { photoInput.value = ''; return }
        pendingFile = f
        try { const u = URL.createObjectURL(f); previewOverlay._currentUrl = u; previewOverlay._img.src = u } catch {}
        previewOverlay.classList.remove('hidden')
        plusMenu.classList.add('hidden')
      }
      }
      socket.on('message', m => {
        renderMessage(m)
        if (m.sender === 'agent' && isActive && atBottom()) socket.emit('seen', { phone: currentPhone })
      })
  socket.on('recalled', r => {
    const el = messagesEl.querySelector('[data-id="' + r.id + '"]')
    if (!el) return
    el.remove()
    msgs = msgs.filter(x => x.id !== r.id)
  })
    // è¯­è¨€ä¸æ–‡æ¡ˆï¼ˆä»…æ”¯æŒ es/enï¼‰
    const isEs = langParam === 'es'
    const isEn = langParam === 'en'
    if (serviceLabel) {
      serviceLabel.textContent = isEs ? 'Soporte en lÃ­nea' : 'Online Support'
    }
    messageInput.placeholder = placeholderParam ? decodeURIComponent(placeholderParam) : (isEs ? 'Escribir mensaje' : 'Enter message')
    // å‘é€æŒ‰é’®æ˜¾ç¤ºå›¾æ ‡ï¼Œä¸ä½¿ç”¨æ–‡å­—
    backBtn.onclick = () => {
      try { window.close(); } catch {}
      try {
        if (window.history && typeof window.history.back === 'function') {
          window.history.back()
        } else {
          location.href = '/me'
        }
      } catch { location.href = '/me' }
    }
  
  if (presetPhone) {
    startChat(presetPhone, presetName || '', presetAvatar || '')
  }
    let replyPreview
    let replyText
    let replyCancel
    replyPreview = document.createElement('div')
    replyPreview.className = 'reply-preview hidden'
    replyText = document.createElement('div')
    replyText.className = 'reply-preview-text'
    replyCancel = document.createElement('button')
    replyCancel.className = 'reply-preview-cancel'
    replyCancel.textContent = 'å–æ¶ˆå¼•ç”¨'
    replyPreview.appendChild(replyText)
    replyPreview.appendChild(replyCancel)
    composerEl.insertBefore(replyPreview, messageInput)
    replyCancel.onclick = () => { replyToId = null; replyPreview.classList.add('hidden'); replyText.textContent = ''; scrollChatToBottom() }
    function setReply(m) {
      replyToId = m.id || null
      replyText.textContent = m.type === 'image' ? 'å›¾ç‰‡' : (m.content || '')
      replyPreview.classList.remove('hidden')
      scrollChatToBottom()
    }
    let activeMsgMenu = null
    function openMsgMenu(e, m) {
      if (activeMsgMenu) { activeMsgMenu.remove(); activeMsgMenu = null }
      const menu = document.createElement('div')
      menu.className = 'msg-menu'
      const mk = (text, cls, fn) => { const it = document.createElement('div'); it.className = 'msg-menu-item' + (cls ? ' ' + cls : ''); it.textContent = text; it.onclick = () => { fn(); closeMenu() }; return it }
      const closeMenu = () => { if (activeMsgMenu) { activeMsgMenu.remove(); activeMsgMenu = null; } }
      menu.appendChild(mk(labelReply, '', () => setReply(m)))
      menu.appendChild(mk(labelCopy, '', () => { const v = m.type === 'image' ? m.content : (m.content || ''); if (navigator.clipboard) navigator.clipboard.writeText(v) }))
      if (m.sender === 'customer') menu.appendChild(mk(labelRecall, 'danger', () => { socket.emit('recall', { phone: currentPhone, id: m.id, by: 'customer' }) }))
      menu.style.top = Math.min((e.clientY || 100), window.innerHeight - 160) + 'px'
      menu.style.left = Math.min((e.clientX || 100), window.innerWidth - 160) + 'px'
      document.body.appendChild(menu)
      activeMsgMenu = menu
      document.addEventListener('click', closeMenu, { once: true })
    }
    sendBtn.innerHTML = '<svg viewBox="0 0 24 24" width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M12 3l-6 6h4v8h4V9h4l-6-6z" fill="#fff"/></svg>'
    sendBtn.onclick = async () => {
      const content = messageInput.value.trim()
      if (!content) return
      if (!currentPhone) {
        let p = localStorage.getItem('anon_phone') || presetPhone || ''
        if (!p) {
          p = 'anon_' + Date.now()
          localStorage.setItem('anon_phone', p)
          await fetch('/api/user', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ phone: p, name: '', avatar: '' }) })
        }
        currentPhone = p
        socket.emit('join', { phone: currentPhone, role: 'customer' })
      }
      socket.emit('message', { phone: currentPhone, sender: 'customer', content, reply_to: replyToId })
      messageInput.value = ''
      messageInput.style.height = 'auto'
      try { updateComposerHeight() } catch {}
      replyToId = null
      try { if (replyPreview) replyPreview.classList.add('hidden') } catch {}
      scrollChatToBottom()
    }
    messageInput.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey && !e.isComposing) {
        e.preventDefault()
        sendBtn.click()
      }
    })
  </script>
</body>
</html>